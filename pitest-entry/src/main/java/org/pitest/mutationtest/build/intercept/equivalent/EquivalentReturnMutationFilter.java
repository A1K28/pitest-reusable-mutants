package org.pitest.mutationtest.build.intercept.equivalent;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.objectweb.asm.Opcodes;
import org.pitest.bytecode.analysis.ClassTree;
import org.pitest.bytecode.analysis.MethodMatchers;
import org.pitest.bytecode.analysis.MethodTree;
import org.pitest.functional.F;
import org.pitest.functional.FCollection;
import org.pitest.functional.prelude.Prelude;
import org.pitest.mutationtest.build.InterceptorParameters;
import org.pitest.mutationtest.build.InterceptorType;
import org.pitest.mutationtest.build.MutationInterceptor;
import org.pitest.mutationtest.build.MutationInterceptorFactory;
import org.pitest.mutationtest.engine.Mutater;
import org.pitest.mutationtest.engine.MutationDetails;
import org.pitest.mutationtest.engine.gregor.mutators.PrimitiveReturnsMutator;
import org.pitest.plugin.Feature;

/**
 * Tightly coupled to the PrimitiveReturnsMutator - removes trivially equivalent mutants generated by this
 * operator
 *
 */
public class EquivalentReturnMutationFilter implements MutationInterceptorFactory {

  @Override
  public String description() {
    return "Trivial return vals equivalence filter";
  }

  @Override
  public Feature provides() {
    return Feature.named("FRETEQUIV")
        .withOnByDefault(true)
        .withDescription("Filters return vals mutants with bytecode equivalent to the unmutated class");

  }

  @Override
  public MutationInterceptor createInterceptor(InterceptorParameters params) {
    return new TrivialEquivalanceFilter();
  }

}

class TrivialEquivalanceFilter implements MutationInterceptor {
  
  private static final String MUTATOR_ID = PrimitiveReturnsMutator.PRIMITIVE_RETURN_VALS_MUTATOR.getGloballyUniqueId();
  
  private static final Set<Integer> ZERO_CONSTANTS = new HashSet<Integer>();
  static {
    ZERO_CONSTANTS.add(Opcodes.ICONST_0);
    ZERO_CONSTANTS.add(Opcodes.LCONST_0);
    ZERO_CONSTANTS.add(Opcodes.FCONST_0);
    ZERO_CONSTANTS.add(Opcodes.DCONST_0);
  }
  
  private ClassTree currentClass;

  @Override
  public InterceptorType type() {
    return InterceptorType.FILTER;
  }

  @Override
  public void begin(ClassTree clazz) {
    currentClass = clazz;
  }

  @Override
  public Collection<MutationDetails> intercept(
      Collection<MutationDetails> mutations, Mutater m) {
    return FCollection.filter(mutations, Prelude.not(isEquivalent(m)));
  }

  private F<MutationDetails, Boolean> isEquivalent(Mutater m) {
    return new F<MutationDetails, Boolean>() {
      @Override
      public Boolean apply(MutationDetails a) {
        if (!a.getMutator().equals(MUTATOR_ID)) {
          return false;
        }
        int intructionBeforeReturn = a.getInstructionIndex() - 1;
        MethodTree method = currentClass.methods().findFirst(MethodMatchers.forLocation(a.getId().getLocation())).value();
        return ZERO_CONSTANTS.contains(method.instructions().get(intructionBeforeReturn).getOpcode());
      }

    };
  }

  @Override
  public void end() {
    currentClass = null;
  }
  
}


